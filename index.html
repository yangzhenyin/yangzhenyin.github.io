<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="Write less do more!">
<meta property="og:type" content="website">
<meta property="og:title" content="牛顿丶博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="牛顿丶博客">
<meta property="og:description" content="Write less do more!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="牛顿丶博客">
<meta name="twitter:description" content="Write less do more!">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>


  <title> 牛顿丶博客 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">牛顿丶博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/01/Angular/" itemprop="url">
                  Angular
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-01T23:44:41+08:00" content="2016-12-01">
              2016-12-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Angular-总结"><a href="#Angular-总结" class="headerlink" title="Angular 总结"></a>Angular 总结</h2><h3 id="1、使用场景"><a href="#1、使用场景" class="headerlink" title="1、使用场景"></a>1、使用场景</h3><pre><code>angular 主要是用来做一些单页面应用和后天管理系统，angular的缺点是里面的数据是通过动态帮顶
接口动态创建出来的，不利于搜索引擎中的爬虫爬取到关键字的信息。
</code></pre><h3 id="2、自己使用-Angular-做过-angular版的-todoList-的demo。"><a href="#2、自己使用-Angular-做过-angular版的-todoList-的demo。" class="headerlink" title="2、自己使用 Angular 做过 angular版的 todoList 的demo。"></a>2、自己使用 Angular 做过 angular版的 todoList 的demo。</h3><h3 id="3、通过锚点定位"><a href="#3、通过锚点定位" class="headerlink" title="3、通过锚点定位"></a>3、通过锚点定位</h3><pre><code>&lt;a href=&quot;#gogo&quot;&gt;定位&lt;/a&gt;  //点击上面这个 a 标签会定位到下面的那个标签的位置

&lt;a name=&quot;gogo&quot;&gt;要定位的位置&lt;/a&gt;  
</code></pre><h3 id="4、前端路由跳转"><a href="#4、前端路由跳转" class="headerlink" title="4、前端路由跳转"></a>4、前端路由跳转</h3><pre><code>1. 通过 a 标签的锚点（hash）实现前端路由 url 的跳转，实际是通过监听 hash 的改变来渲染不同
的页面，之所以不用传统的 a 标签的 href 属性，是因为传统的 a 的标签的 href 会真的发送请求跳转页面，虽然通过注册事件也可以最终实现目的，但是太麻烦了。

2. 所谓的单页应用实际就是利用 hash 做网页内部局部内容的替换
    01. 为什么不适用传统而路径？
        因为传统的路径会默认发同步请求跳转。
    02. 为什么 hash 中的路径都是以 &apos;/&apos; 开头，是为了区分普通的 hash
</code></pre><h3 id="5、单页应用"><a href="#5、单页应用" class="headerlink" title="5、单页应用"></a>5、单页应用</h3><pre><code>1. 实际就是利用 hash 请求数据替换局部内容。

2. SPA 单页面的核心： 就是通过监听锚点事件变化，获取锚点内容，根据不同的锚点做不同的内容
改变

3. 如何在网页中解析 URL 地址：
    01 字符串操作
    02 正则匹配
    03 a 标签的 DOM 操作  a.hash 请求hash， a.host 请求路径  a.port 请求端口号
        a.protocol  请求协议

4. 单页应用的好处
    提高了整个应用程序的响应速度、增加了用户体验。
    重用资源
    方便统一管理和代码重用   
</code></pre><h3 id="6、在页面中定义和加载使用模块"><a href="#6、在页面中定义和加载使用模块" class="headerlink" title="6、在页面中定义和加载使用模块"></a>6、在页面中定义和加载使用模块</h3><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;!-- 将模块作用到视图中 --&gt;
&lt;body ng-app=&quot;DemoApp&quot;&gt;
    &lt;!-- 引用控制器函数 --&gt;
    &lt;div ng-controller=&quot;DemoController_01&quot;&gt;
        &lt;h2&gt;{{ num1 }}&lt;/h2&gt;
    &lt;/div&gt;
    &lt;!-- 引用控制器函数 --&gt;
    &lt;div ng-controller=&quot;DemoController_02&quot;&gt;
        &lt;h2&gt;{{ num2 }}&lt;/h2&gt;
    &lt;/div&gt;
    &lt;!-- 引用控制器函数 --&gt;
    &lt;div ng-controller=&quot;DemoController_03&quot;&gt;
        &lt;h2&gt;{{ num3 }}&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script src=&quot;js/angular-1.2.3.js&quot;&gt;&lt;/script&gt;
    &lt;!-- &lt;script src=&quot;js/angular.js&quot;&gt;&lt;/script&gt; --&gt;
    &lt;script&gt;
        //1. 定义模块，可以使用变量接收定义好的模块
        //          angular.module(&quot;模块名&quot;, [])，如果里面是一个参数就表示获取一个模
        块，两个参数，第二个参数
        //          是数组，这个数组表示该模块的依赖，空数组表示没有依赖，同时创建一个模
        块，如果有依赖，在数
        //          组中指定依赖的模块名，类似于 require 的作用
        //2. 在该模块中定义控制器函数
        //3. 将模块和控制器作用到视图， 首先使用 ng-app=&quot;模块名&quot; ，将模块作用到视图中，
        // 然后再引用控制器函数 ng-controller=&quot;函数名&quot;
        //定义模块，可以使用变量接收定义好的模块，也可以直接使用
        //创建控制器最正确的方式是使用数组，在数组引入依赖项
        //有三种定义控制器函数的方法
        //1.定义好模块直接在后面定义控制器函数
        var demoApp = angular.module(&quot;DemoApp&quot;, [])
            .controller(&apos;DemoController_01&apos;, [&apos;$scope&apos;, function ($scope) {
                //初始化数据模型模型成员
                $scope.num1 = &apos;这是直接在模块后面定义控制器函数 ====
                 DemoController_01&apos;;
            }]);
        //2. 使用接收定义模块返回值的变量定义控制器函数
        demoApp.controller(&apos;DemoController_02&apos;, [&apos;$scope&apos;, function($scope) {
            //这是使用接收定义好的模块返回值的变量定义控制器函数
            //初始化数据模型成员
            $scope.num2 = &apos;这是使用接收定义好的模块返回值的变量定义控制器函数 ====
             DemoController_02&apos;;
        }]);
        //3. 直接获取定义好的模块，定义控制器函数
        angular.module(&quot;DemoApp&quot;).controller(&apos;DemoController_03&apos;, [&apos;$scope&apos;, function($scope) {
            //初始化数据模型成员
            $scope.num3 = &apos;直接获取定义好的模块，定义控制器函数 ====
             DemoController_03&apos;
        }])
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/16/事件/" itemprop="url">
                  事件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-16T23:44:41+08:00" content="2016-06-16">
              2016-06-16
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JS-事件"><a href="#JS-事件" class="headerlink" title="JS 事件"></a>JS 事件</h2><pre><code>这两种事件都代表的是页面文档加载时触发的，但两者之间区别在于：

ready 事件的触发，表示文档结构已经加载完成（不包含图片等非文字媒体文件）。
onload 事件的触发，表示页面包含图片等文件在内的所有元素都加载完成。
</code></pre><h3 id="事件机制：-事件冒泡和事件捕获"><a href="#事件机制：-事件冒泡和事件捕获" class="headerlink" title="事件机制： 事件冒泡和事件捕获"></a>事件机制： 事件冒泡和事件捕获</h3><pre><code>1、事件冒泡和事件捕获：
    事件捕获是自上而下的，而事件冒泡是自下而上的。

    （1） 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序
    触发。

     IE 5.5: div -&gt; body -&gt; document

     IE 6.0: div -&gt; body -&gt; html -&gt; document

     Mozilla 1.0: div -&gt; body -&gt; html -&gt; document -&gt; window

    （2） 捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然
    后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。

    支持W3C标准的浏览器在添加事件时用addEventListener(event,fn,useCapture)方法，其中第
    3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执
    行。而不兼容W3C的浏览器(IE)用attachEvent()方法，此方法没有相关设置，不过IE的事件模
    型默认是在事件冒泡时执行的，也就是在useCapture等于false的时候执行，所以把在处理事
    件时把useCapture设置为false是比较安全，也实现兼容浏览器的效果。

    事件捕获阶段：事件从最上一级标签开始往下查找，直到捕获到事件目标(target)。
    事件冒泡阶段：事件从事件目标(target)开始，往上冒泡直到页面的最上一级标签。

    假设一个元素div，它有一个下级元素p。
    &lt;div&gt;
    　　&lt;p&gt;元素&lt;/p&gt;
    &lt;/div&gt;
    这两个元素都绑定了click事件，如果用户点击了p，它在div和p上都触发了click事件，那这两
    个事件处理程序哪个先执行呢？事件顺序是什么？

    两种模型
    以前，Netscape和Microsoft是不同的实现方式。

    Netscape中，div先触发，这就叫做事件捕获。

    Microsoft中，p先触发，这就叫做事件冒泡。

    两种事件处理顺序刚好相反。IE只支持事件冒泡，Mozilla, Opera 7 和 Konqueror两种都支持，
    旧版本的Opera&apos;s 和 iCab两种都不支持 。

    事件捕获
    当你使用事件捕获时，父级元素先触发，子级元素后触发，即div先触发，p后触发。

    事件冒泡
    当你使用事件冒泡时，子级元素先触发，父级元素后触发，即p先触发，div后触发。

    W3C模型
    W3C模型是将两者进行中和，在W3C模型中，任何事件发生时，先从顶层开始进行事件捕获，直到
    事件触发到达了事件源元素。然后，再从事件源往上进行事件冒泡，直到到达document。

    程序员可以自己选择绑定事件时采用事件捕获还是事件冒泡，方法就是绑定事件时通过
    addEventListener函数，它有三个参数，第三个参数若是true，则表示采用事件捕获，若
    是false，则表示采用事件冒泡。

    ele.addEventListener(&apos;click&apos;,doSomething2,true)

    true=捕获

    false=冒泡

    传统绑定事件方式
    在一个支持W3C DOM的浏览器中，像这样一般的绑定事件方式，是采用的事件冒泡方式。

    ele.onclick = doSomething2

    IE浏览器
    如上面所说，IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，
    不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。

    ele.attachEvent(&quot;onclick&quot;, doSomething2);

    附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，
    沿着文档逐层向上冒泡，到document为止。

    事件的传播是可以阻止的：
    • 在W3c中，使用stopPropagation（）方法
    • 在IE下设置cancelBubble = true；
    在捕获的过程中stopPropagation（）；后，后面的冒泡过程也不会发生了~
    （3）阻止事件的默认行为，例如click &lt;a&gt;后的跳转~
    • 在W3c中，使用preventDefault（）方法；
    • 在IE下设置window.event.returnValue = false;
    （4）不是所有的事件都能冒泡，例如：blur、focus、load、unload就不能事件冒泡。

2、事件绑定：

 分别是bind、live、delegate、on，对应的解除监听的函数分别是unbind、die、undelegate、off。
  DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/20/面向对象/" itemprop="url">
                  面向对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-20T01:05:32+08:00" content="2016-03-20">
              2016-03-20
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>  1、面向对象和面向过程的区别：</p>
<ul>
<li><p>面向对象</p>
<ul>
<li>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</li>
</ul>
</li>
<li><p>面向过程</p>
<ul>
<li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</li>
</ul>
<p>2、异常捕获</p>
<p>使用 try {</p>
<pre><code>    这里面是可能发生错误的代码
} 
catch(e) {
    这里面是能够正常执行的代码
};
当一段代码可能发生错误，这个错误现在这个阶段没法解决，为了是后面的代码正常的运行，
就进行异常捕获。
</code></pre><p>3、创建对象</p>
<ol>
<li><p>使用 Object 构造函数创建一个对象</p>
<p> var person = new Object();<br> person.name = ‘牛顿’;<br> person.age = 18;</p>
</li>
<li><p>使用对象字面量创建对象。不要奇怪person[“5”],这里是合法的；另外使用这种加括号的方式字段之间是可以有空格的如person[“my age”].</p>
<p> var person = {</p>
<pre><code>    name: &apos;牛顿&apos;,
    age: 18,
    5: &apos;test&apos;
};
</code></pre><p> alert(person.name);<br> alert(person[“5”]);</p>
</li>
<li><p>使用工厂模式创建对象,返回带有属性和方法的person对象。</p>
<p> function createPerson(name, age,job) {</p>
<pre><code>    var o = new Object();
    o.name=name;
    o.age=31;
    o.sayName=function() {
        alert(this.name);
    };
    return o;
}
</code></pre><p> createPerson(“kevin”,31,”se”).sayName();</p>
</li>
<li><p>使用自定义构造函数模式创建对象；这里注意命名规范，作为构造函数的函数首字母要大写，以区别其它函数。这种方式有个缺陷是sayName这个方法，它的每个实例都是指向不同的函数实例，而不是同一个。</p>
<p> function Person(name, age, job) {</p>
<pre><code>this.name = name;
this.age = age;
this.job = job;
this.sayName = function () {
    alert(this.name);
};
</code></pre><p> }</p>
<p> var person = new Person(“kevin”, 31, “SE”);<br> person.sayName();</p>
</li>
<li><p>使用原型模式创建对象； 解决了方法4中提到的缺陷， 使不同的对象的函数（ 如sayFriends） 指向了同一个函数。 但它本身也有缺陷， 就是实例共享了引用类型friends， 从下面的代码执行结果可以看到， 两个实例的friends的值是一样的， 这可能不是我们所期望的。<br> 复制代码</p>
<p> function Person() {</p>
<p> }</p>
<p> Person.prototype = {</p>
<pre><code>constructor: Person,
name: &quot;kevin&quot;,
age: 31,
job: &quot;SE&quot;,
friends: [&quot;Jams&quot;, &quot;Martin&quot;],
sayFriends: function () {
    alert(this.friends);
}
</code></pre><p> };<br> var person1 = new Person();<br> person1.friends.push(“Joe”);<br> person1.sayFriends(); //Jams,Martin,Joe</p>
<p> var person2 = new Person();<br> person2.sayFriends(); //James,Martin,Joe</p>
</li>
<li><p>组合使用原型模式和构造函数创建对象， 解决了方法5中提到的缺陷， 而且这也是使用最广泛、 认同度最高的创建对象的方法。<br> 复制代码</p>
<p> function Person(name, age, job) {</p>
<pre><code>this.name = name;
this.age = age;
this.job = job;　　
this.friends = [&quot;Jams&quot;, &quot;Martin&quot;];
</code></pre><p> }<br> Person.prototype.sayFriends = function () {</p>
<pre><code>alert(this.friends);
</code></pre><p> };<br> var person1 = new Person(“kevin”, 31, “SE”);<br> var person2 = new Person(“Tom”, 30, “SE”);<br> person1.friends.push(“Joe”);<br> person1.sayFriends(); //Jams,Martin,Joe<br> person2.sayFriends(); //Jams,Martin</p>
<p> 复制代码</p>
</li>
<li><p>动态原型模式； 这个模式的好处在于看起来更像传统的面向对象编程， 具有更好的封装性， 因为在构造函数里完成了对原型创建。 这也是一个推荐的创建对象的方法。<br> 复制代码</p>
<p> function Person(name, age, job) {</p>
<pre><code>//属性
this.name = name;
this.age = age;
this.job = job;
this.friends = [&quot;Jams&quot;, &quot;Martin&quot;];
//方法
if (typeof this.sayName != &quot;function&quot;) {
    Person.prototype.sayName = function () {
        alert(this.name);
    };

    Person.prototype.sayFriends = function () {
        alert(this.friends);
    };
}
</code></pre><p> }</p>
<p> var person = new Person(“kevin”, 31, “SE”);<br> person.sayName();<br> person.sayFriends();</p>
</li>
</ol>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/10/Ajax/" itemprop="url">
                  Ajax
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-10T20:02:02+08:00" content="2015-09-10">
              2015-09-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Ajax-编程"><a href="#Ajax-编程" class="headerlink" title="Ajax 编程"></a>Ajax 编程</h2><p>  1、C/S结构： 是 Client 客户端 和  Server 服务端 </p>
<pre><code>在C/S结构的情况下，不同的服务需要安装不同的客户端软件，比如QQ、迅雷、Foxmail这种
情况下安装的软件会越来越多，同时也有许多弊端，比如A出差，需要在B电脑上查收邮件，但
是B电脑并未安装Foxmail等类似的客户端软件，这样不得不先去下载Foxmail，非常不方便。
</code></pre><p>  2、B/S结构： 是 Browser 浏览器 和 Server 服务端 </p>
<pre><code>解决了C/S所带来的不便，将所有的服务都可以通过浏览器来完成（因为基本所有浏览器都安
装了浏览器），但B/S也有一些不利，比如操作稳定性、流畅度等方面相对较弱。
</code></pre><p>  3、注：GET和POST请求方式的差异（面试题）</p>
<pre><code>1、GET没有请求主体，使用xhr.send(null)
2、GET可以通过在请求URL上添加请求参数
3、POST可以通过xhr.send(&apos;name=itcast&amp;age=10&apos;)
4、POST需要设置 xhr.setRequestHeader(&apos;Content-Type&apos;, 
                                    &apos;application/x-www-form-urlencoded&apos;);
5、GET效率更好（应用多）
6、GET大小限制约4K，POST则没有限制
</code></pre><p>  4、接口化开发</p>
<pre><code>请求地址即所谓的接口，通常我们所说的接口化开发，其实是指一个接口对应一个功能，并且
严格约束了请求参数和响应结果的格式，这样前后端在开发过程中，可以减少不必要的讨论，
从而并行开发，可以极大的提升开发效率，另外一个好处，当网站进行改版后，服务端接口只
需要进行微调。
</code></pre><p>   5、Ajax的请求过程</p>
<pre><code>//1. 初始化ajax内置函数
var xhr = new XMLHttpRequest();

//2. 请求头
xhr.open(&apos;请求方式&apos;, &apos;接口地址&apos;, &apos;async&apos;);

//请求方式分为get请求和post请求
//接口地址: get请求时由接口地址和要传送的内容组成用&apos;?&apos;号和&amp;连接
// post请求时只需要设置接口地址
// async 为true时是异步，false是同步，默认异步

//3. 设置请求头
//只有是post请求的时候才需要设置请求头，get不需要设置
xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);

//4. 请求主体
//当为get请求时设置为null
xhr.send(null);

//当为post请求时设置的需要传输的内容，用&amp;连接
xhr.send(name=牛顿);

//5. 监听响应的状态readystatechange事件
xhr.onreadystatechange = function() {
    //判断响应是否完成用readyState,等于4时响应完成
    //判断响应是否正常用status，等于200时响应正常
    if (xhr.readyState ==4 &amp;&amp; xhr.status ==200) {
        //要处理的逻辑
    }

};
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/16/CSS3和移动Web/" itemprop="url">
                  CSS3 和移动 Web
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-16T23:46:34+08:00" content="2015-05-16">
              2015-05-16
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、CSS3"><a href="#一、CSS3" class="headerlink" title="一、CSS3"></a>一、CSS3</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>图片的宽度会继承父元素。<ul>
<li><code>z-index</code> 是设置层级</li>
</ul>
</li>
<li>常用字体格式<ul>
<li>.otf 常用浏览器：Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+；</li>
<li>.woff 常用浏览器：IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；</li>
<li>.eot 是 IE 专用字体</li>
<li>.svg 常用浏览器：Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+；</li>
</ul>
</li>
</ul>
<h4 id="CSS3-的兼容性解决"><a href="#CSS3-的兼容性解决" class="headerlink" title="CSS3 的兼容性解决"></a>CSS3 的兼容性解决</h4><ul>
<li>一般是加私有前缀<ol>
<li>-webkit-border-radius: 50%; 适用于谷歌 chrome</li>
<li>-moz-  适用于火狐 Firefox</li>
<li>-o- 针对欧朋</li>
<li>-ms- 针对 IE </li>
</ol>
</li>
<li>如不能解决，应尽量避免使用</li>
</ul>
<h2 id="二、移动-web-开发"><a href="#二、移动-web-开发" class="headerlink" title="二、移动 web 开发"></a>二、移动 web 开发</h2><p>   1、怎么设置 viewport，才能达到移动端的适配，需要满足什么条件</p>
<pre><code>1. 我们看到的页面比例必须和 PC 端保持一致
2. 网页的内容宽度必须和移动端设备的宽度保持一致
3. 不允许用户自行缩放网页
</code></pre><p>   2、设置 viewport 视口用来满足以上条件<br>    <!--国际上通用的移动web页面的设置 标准化的设置--><br>    (01) <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0"><br>        设置视口 viewport<br>        width=device-width  设置视口宽度，是当前设备的宽度<br>        initial-scale=1.0 设置 viewport 的初始化缩放比是 1.0，不放大，也不缩小，和在 PC 端显示的比例一样<br>        user-scalable=0 设置是否允许用户缩放， 0 / no 是不允许， 1 / yes 是允许<br>        maximum-scale   是设置最大允许缩放比<br>        minimum-scale   是设置最小允许缩放比<br>        这样设置之后就构建了一个标准的移动 Web 页面</p>
<p>   3、清除浮动<br>        1、使用空标签清除浮动<br>            <ul><br>                <li>AAA</li><br>                <li>BBB</li><br>                <li>CCC</li><br>                <br style="clear:both"><br>            </ul><br>        2、使用 overflow 属性<br>            <ul style="overflow: hidden;zoom:1"><br>                <li>AAA</li><br>                <li>BBB</li><br>                <li>CCC</li><br>            </ul><br>        3、添加伪元素<br>        .clearfix::before,.clearfix::after {<br>                content: “”;<br>                display: block;<br>                visibility: hidden;<br>                height: 0;<br>                line-height: 0;<br>                clear: both;<br>            }</p>
<p>   4、移动端的问题<br>        安卓和IOS视口设置有什么区别？<br>            <!-- 答: IOS：<meta name="apple-mobile-web-app-title" content="标题">  --><br>            答：<br>        300ms延时？<br>            答: (1) 300ms 延时的原因是在移动端使用 click 事件的时候会有一个 300ms 的延时，解决方法是通过封装一个 tap()方法，里面的具体过程是用 touchstart 、touchmove和touchend 方法的结合，判断从开始触摸到结束触摸并且没有触发触摸移动事件的时间有没有超过 150ms，没有超过就认为触发了 tap 方法，然后执行回调函数，处理对应的逻辑，若是超过了 150ms，就认为失败，跳过，不执行回调函数。<br>                (2) 使用 fastClick 框架，解决 click 300ms 延时问题。</p>
<p>   5、移动端事件  </p>
<ul>
<li>touchstart：当手指触碰屏幕时候发生。不管当前有多少只手指</li>
<li>touchmove：当手指在屏幕上连续滑动的时候触发。通常我们</li>
<li>在滑屏页面会调用 event 的 preventDefault() 可以用来阻止默认情况的发生。阻止页面滚动</li>
<li>touchend：当手指离开屏幕时触发。</li>
<li>touchcancel：当系统停止跟踪触摸时触发。</li>
<li>触摸事件的响应顺序<ul>
<li>1、ontouchstart</li>
<li>2、ontouchmove</li>
<li>3、ontouchend</li>
<li>4、onclick  300ms延时</li>
</ul>
</li>
</ul>
<p>   6、/<em>在移动端清除浏览器默认样式</em>/<br>        -webkit-appearance: none;</p>
<p>   7、时间戳</p>
<pre><code>var time = Date.now() / new Date().now() 时间戳，从 1970年到现在时间的毫秒数
</code></pre><p>解决 300ms 延时问题 </p>
<p>   8、Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。</p>
<pre><code>Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。
设计的目的是提供jquery的类似的APIs，但并不是100%覆盖jquery为目的。
</code></pre><p>   9、swiper 是一个用于控制滑动的插件，可以设置要滑动的DOM对象，是否滑动，滑动的缓冲距离。</p>
<pre><code>itcast.iScroll({
    swipeDom:document.querySelector(&apos;.jd_category_right&apos;),
    swipeType:&apos;y&apos;,
    swipeDistance:50
});
</code></pre><h2 id="二、响应式开发"><a href="#二、响应式开发" class="headerlink" title="二、响应式开发"></a>二、响应式开发</h2><p>   1、媒体查询: 通过<code>@media screen</code>媒体查询，当检测到当前 screen （屏幕）的宽度位于某个宽度区间时显示不同的网络布局。</p>
<pre><code>1、xs-超小屏幕 768px 以下             --- 手机
2、sm-小屏设备 768px-992px            --- 平板
3、md-中等屏幕 992px-1200px           --- 标屏 窄屏设备
4、lg-超大屏幕 1200px 以上            --- 笔记本 显示器 大屏设备
</code></pre><p>   2、响应式开发的原理 </p>
<pre><code>1、媒体查询和栅格系统
    + 栅格系统 
        - .row 是行，无固定高度，左右各有一个 15px 的 margin-right: 15px; 
        margin-left: 15px;一行默认是12份。
        - .col-*-* 是列，第一个 * 代表是在什么屏幕下，第二个 * 代表这个元素占一行的
        多少份
    + 列偏移
        - .col-md-offset-数字  在中屏上偏移的行的份数，类似于margin
    + 列排序
        - col-xs-pull-9 左拉9份
        - col-xs-push-3 右推3份
    + bootstrap组件 
        - collapse 手风琴
        - carousel 旋转木马
        - Affix 在固定位置显示
2、注意项
    &lt;!-- 指定编码格式 --&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;!-- 当时用IE浏览器的时候，指定使用最新的内核进行渲染 --&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;!-- 进行适配移动端的设置，把viewport设置标准写法，适配移动终端 --&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, 
    user-scalable=no, maximum-scale=1.0, minimum-scale=1.0&quot;/&gt;
    &lt;!-- 引入html5shiv.min.js是为了兼容HTML5的语义化的标签在低版本的浏览器中 --&gt;
    &lt;!-- 这个第三方库的原理是使用 document.createElement(&apos;标签&apos;)对新标签创建一遍，
        然后改成块级元素 display: block; --&gt;
    &lt;!-- 引入respond.min.js 是为了兼容识别 media query(媒体查询)--&gt;
    &lt;!-- 条件注释 --&gt;
    &lt;!--[if lt IE 9]&gt;
    &lt;script src=&quot;lib/html5shiv/html5shiv.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;lib/respond/respond.js&quot;&gt;&lt;/script&gt;
    &lt;![endif]--&gt; 
</code></pre><p> 3、前端框架 </p>
<pre><code>1. AmazeUI(跨终端框架)、BootStrap、
</code></pre><p> 4、模板</p>
<pre><code>1. artTemplate
    (原生语法版)
            &lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt;  
                &lt;%if(admin){%>  
                        <% for(var="" i="0;" i<list.length;="" i++){%="">  
                            <div><%=i%>:<%=list[i].value%></%=list[i].value%></%=i%></div>  
                        <%}%&gt; &lt;%}else{%="">  
                        <div>没有结果！</div>  
                    <%}%&gt; &lt;="" script&gt;="" 1、引入template-native.js="" 2、&lt;%="" 与="" %&gt;="" 符号包裹起来的语句则为模板的逻辑表达式="" 3、&lt;%="content" %&gt;为输出表达式="" (简洁语法版)这个和="" nodejs="" 中的="" pre&gt;&lt;pre="" name="&quot;code&quot;" class="&quot;javascript&quot;&gt;&lt;script" id="&quot;test&quot;" type="&quot;text/html&quot;&gt;" {{if="" admin}}="" {{each="" list="" as="" value="" index}}="" &lt;div&gt;{{index}}:{{value}}&lt;="" div&gt;="" {{="" each}}="" {{else="" if}}="" 条件判断="" 2.="" xtpl模板，是="" 中使用的模板。="" 3.="" underscore，在这个模板中有一个="" _.template()方法，把获取到的内容用template方法转化成模板方法="" var="" templatepointfuc="_.template(templatePointContent);" *="" 生成轮播图的数据="" function="" banner()="" {="" data="[" m_img:="" &quot;images="" slide_01_640x340.jpg&quot;,="" pc_img:="" slide_01_2000x410.jpg&quot;="" },="" slide_02_640x340.jpg&quot;,="" slide_02_2000x410.jpg&quot;="" slide_03_640x340.jpg&quot;,="" slide_03_2000x410.jpg&quot;="" slide_04_640x340.jpg&quot;,="" slide_04_2000x410.jpg&quot;="" }="" ];="" （1）这个方法是通过获取模板的内容动态的生成轮播图，有数据传输="" 通过id获取到模板里面的数据="" randerhtml="function()" 获取页面窗口的宽度="" width="$(window).width();" ismobile="width" 768?="" true="" :="" false;="" 获取样式小点中的模板内容="" templatepointcontent="$(&quot;#wjs_point_box&quot;).html();" 把获取到的内容用template方法转化成模板方法="" 在模板方法中，传入数据，转化成html结构="" 如果只是用弄好的静态页面做模板动态生成，这里的括号里面不传入数据也可以动态生成="" 这里的lis只是一个json对象的变量，在动态生成轮播图的时候用到的时lis对象的date属性里面的json对象值="" templatepointhtml="templatePointFuc({lis:Data});" 渲染在页面上="" $(&quot;ol&quot;).html(templatepointhtml);="" 获取装载图片的盒子的模板内容="" templatebannercontent="$(&quot;#wjs_banner_box&quot;).html();" templatebannerfuc="_.template(templateBannerContent);" 这里使用的是lis这个变量对象中的date中的属性值，lis只是个对象变量，重要的是后面的data中的数据="" templatebannerhtml="templateBannerFuc({lis:Data," ism:ismobile});="" 通过对象属性把值传过去="" $(&quot;#wjs_banner_img_box&quot;).html(templatebannerhtml);="" };="" 刷新一次，就执行一次="" $(window).on(&quot;resize&quot;,="" function()="" randerhtml();="" }).trigger(&quot;resize&quot;);="" 这里的trigger是加载一面是强制行的就刷新一次="" <="" code=""></%}%&gt;></%}%&gt;></%></code></pre><p>   5、监听刷新事件</p>
<pre><code>//刷新一次，就执行一次
$(window).on(&quot;resize&quot;, function() {
    randerHtml();
}).trigger(&quot;resize&quot;);
//这里的trigger是加载一面是强制行的就刷新一次
</code></pre><p>   6、存储</p>
<pre><code>1. sessionStorage约5M，localStorage约20M，只能存储字符串，对于对象，使用 
JSON.stringify()编码成字符串后存储。
2. window.sessionStorage
    1、生命周期为关闭浏览器窗口
    2、在同一个窗口下数据可以共享
3.  window.localStorage
    1、永久生效，除非手动删除
    2、可以多窗口共享
4. 设置存储
    setItem(key, value) 设置存储内容
    getItem(key) 读取存储内容
    removeItem(key) 删除键值为key的存储内容
    clear() 清空所有存储内容
</code></pre><p>   7、位置坐标的区别：</p>
<ul>
<li><p>event.clientX、event.clientY</p>
<ul>
<li>鼠标相对于浏览器窗口可视区域的X，Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。IE事件和标准事件都定义了这2个属性</li>
</ul>
</li>
<li><p>event.pageX、event.pageY</p>
<ul>
<li>类似于event.clientX、event.clientY，但它们使用的是文档坐标而非窗口坐标。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。</li>
</ul>
</li>
<li><p>event.offsetX、event.offsetY</p>
<ul>
<li>鼠标相对于事件源元素（srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性。</li>
</ul>
</li>
<li><p>event.screenX、event.screenY</p>
<ul>
<li>鼠标相对于用户显示器屏幕左上角的X,Y坐标。标准事件和IE事件都定义了这2个属性</li>
</ul>
<p><img src="image/01.bmp" alt="坐标位置说明">  </p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/10/GitHub/" itemprop="url">
                  GitHub 的简介和常用命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-10T15:26:38+08:00" content="2015-01-10">
              2015-01-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="browser-sync"><a href="#browser-sync" class="headerlink" title="browser-sync"></a>browser-sync</h2><p>官网：<a href="https://browsersync.io/" target="_blank" rel="external">https://browsersync.io/</a></p>
<ul>
<li>必须有node环境</li>
<li><code>npm install -g browser-sync</code></li>
<li><code>browser-sync start --server --files &quot;css/*.css, *.html, js/*.js&quot;</code><ul>
<li>该命令表示启动一个本地服务器，同时监视 –files 指定的文件</li>
</ul>
</li>
</ul>
<h2 id="1-命令行"><a href="#1-命令行" class="headerlink" title="1. 命令行"></a>1. 命令行</h2><p><img src="img/hack.jpg" alt="黑客帝国"></p>
<p>在电影中一个“超级黑客”坐在电脑前，从不摸一下鼠标，<br>就能够在 30 秒内侵入到超安全的军事计算机中。</p>
<p>这是因为电影制片人意识到，作为人类，本能地知道让计算机圆满完成工作的唯一途径，是用键盘来操纵计算机。</p>
<h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><h4 id="1-1-1-GUI-VS-CLI"><a href="#1-1-1-GUI-VS-CLI" class="headerlink" title="1.1.1 GUI VS CLI"></a>1.1.1 GUI VS CLI</h4><p>现在，大多数的计算机用户只是熟悉图形用户界面（GUI），并且产品供应商和此领域的学<br>者会灌输给用户这样的思想，命令行界面（CLI）是过去使用的一种很恐怖的东西。这就很不<br>幸，因为一个好的命令行界面，是用来和计算机进行交流沟通的非常有效的方式，正像人类社<br>会使用文字互通信息一样。人们说， <strong>图形用户界面让简单的任务更容易完成，而命令行界面<br>使完成复杂的任务成为可能</strong> ，到现在这句话仍然很正确。</p>
<h4 id="1-1-2-shell"><a href="#1-1-2-shell" class="headerlink" title="1.1.2 shell"></a>1.1.2 shell</h4><p>一说到命令行，其实真正指的是 <code>shell</code>。</p>
<p><strong>shell 就是一个程序，它接受从键盘输入的命令，然后把命令传递给操作系统去执行。</strong></p>
<p>几乎所有的 Linux 发行版都提供一个名为 <code>bash</code> 的 shell 程序。<br>bash 是 <code>Bourne Again SHell</code> 的首字母缩写，所指的是这样一个事实。</p>
<p><img src="img/shell.jpg" alt="shell"></p>
<h3 id="1-1-3-终端仿真器"><a href="#1-1-3-终端仿真器" class="headerlink" title="1.1.3 终端仿真器"></a>1.1.3 终端仿真器</h3><p>当使用图形用户界面时，我们需要另一个和 shell 交互的叫做终端仿真器的程序。<br>在 Windows 上，一般使用操作系统自带的 <code>cmd</code> 或者 <code>powershell</code>。<br>在 Linux 上，如果是图形用户界面，那么可以使用 <code>terminal</code> 或者 <code>konsole</code>、<code>gnome-terminal</code> 之类<br>的终端仿真器，但基本上，它们都完成同样的事情，让我们能访问 shell，<br>你可能会因为附加的一些花俏功能而喜欢上某个终端。</p>
<p>关于名字，如果有人提到：控制台、终端、bash、shell、terminal 等，一般都是指上面这些。</p>
<p>一般在 Linux 上，都会提供一个 bash 或者 terminal 之类的工具，让你来使用 shell</p>
<h3 id="1-2-安装-Git-for-Windows-客户端体验-shell"><a href="#1-2-安装-Git-for-Windows-客户端体验-shell" class="headerlink" title="1.2 安装 Git for Windows 客户端体验 shell"></a>1.2 安装 Git for Windows 客户端体验 shell</h3><p>Git for Windows 客户端自带了一个终端仿真器：<code>git bash</code></p>
<p>下载地址：<a href="https://git-for-windows.github.io/" target="_blank" rel="external">https://git-for-windows.github.io/</a></p>
<p><a href="https://github.com/git-for-windows/git" target="_blank" rel="external">git for Windows - github 托管地址</a><br>，然后找到 Realease 模块，找到下载的对应版本即可。</p>
<p>注意：虽然在 Windows 上可以通过 cmd 或 powershell 体验终端的使用，<br>但是学习终端最正确的方式是学习 Linux 上的命令行，要更纯正，更强大。</p>
<p>所以，我们这里通过使用 Git for Windows 客户端（自带了一个 bash）可以供我们学习 shell。</p>
<h4 id="1-2-1-打开和退出终端"><a href="#1-2-1-打开和退出终端" class="headerlink" title="1.2.1 打开和退出终端"></a>1.2.1 打开和退出终端</h4><ul>
<li>开始菜单打开</li>
<li>右键打开</li>
<li>通过开始-运行：输入 git-bash 打开（需要PATH环境变量）</li>
</ul>
<h4 id="1-2-2-命令提示符"><a href="#1-2-2-命令提示符" class="headerlink" title="1.2.2 命令提示符"></a>1.2.2 命令提示符</h4><h3 id="1-3-使用终端操作文件系统"><a href="#1-3-使用终端操作文件系统" class="headerlink" title="1.3 使用终端操作文件系统"></a>1.3 使用终端操作文件系统</h3><ul>
<li>绝对路径和相对路径</li>
<li><code>pwd（print working directory）</code></li>
<li><code>cd（change directory）</code><ul>
<li>切换到指定路径（相对路径或绝对路径）</li>
</ul>
</li>
<li><code>ls（list files）</code><ul>
<li><code>ls</code> 列出当前目录文件</li>
<li><code>ls 目录路径</code> 列出指定路径文件</li>
<li><code>ls -a</code> 列出文件并显示隐藏文件或目录</li>
</ul>
</li>
<li><code>cp（copy）</code><ul>
<li><code>cp 源路径 目标路径</code></li>
<li>cp 在复制目录的时候，不会复制里面的子文件或子目录</li>
<li>-r （recursive）递归复制</li>
</ul>
</li>
<li><code>mv（move）</code>：移动文件或者目录，还可以重命名文件或目录</li>
<li><code>mkdir（make directory）</code>：创建目录</li>
<li><code>rm（remove）</code>：删除文件或目录<ul>
<li><code>-rf</code> 递归删除：直接将整个目录包括里面的内容都删掉</li>
</ul>
</li>
<li><code>rmdir</code> 目录名称<ul>
<li>只能删除空目录</li>
</ul>
</li>
<li><code>clear</code>：清屏</li>
<li><code>touch 文件名</code><ul>
<li>根据文件名创建新的文件</li>
</ul>
</li>
<li><code>cat 文件名</code><ul>
<li>查看指定的文本文件</li>
</ul>
</li>
</ul>
<p>案例：命令综合练习</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1. 在桌面下创建一个叫做 `itcast` 的目录</div><div class="line">2. 在 itcast 目录下，分别创建 `dir1` 和 `dir2` 两个子目录</div><div class="line">3. 复制 `code/scripts/main.js` 文件到 `itcast` 目录中</div><div class="line">4. 复制 `code` 目录下的 `js` 目录到 `itcast` 目录中</div><div class="line">5. 将 `itcast/main.js` 文件重命名为 `main-main.js`</div><div class="line">6. 将 `main-main.js` 文件移动到 dir1 中</div><div class="line">7. 将 `dir1` 中的 `main-main.js` 文件移动到 dir2 中</div><div class="line">8. 将 `itcast/js` 目录删除</div></pre></td></tr></table></figure>
<h3 id="1-4-使用-less-命令浏览文件内容"><a href="#1-4-使用-less-命令浏览文件内容" class="headerlink" title="1.4 使用 less 命令浏览文件内容"></a>1.4 使用 less 命令浏览文件内容</h3><p>less 命令是一个用来浏览文本文件的程序。</p>
<p>less 命令是这样使用的：<code>less 文本文件名</code></p>
<p>一旦 less 程序运行起来，我们就能浏览文件内容了。<br>如果文件内容多于一页，那么我们可以上下滚动文件。按下 <code>q</code> 键，退出 less 程序。</p>
<p>下表列出了 less 程序最常使用的键盘命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">命令               行为</div><div class="line">h                  显示帮助屏幕</div><div class="line">Page UP or b       向上翻滚一页</div><div class="line">Page Down or space 向下翻滚一页</div><div class="line">UP Arrow           向上翻滚一行</div><div class="line">Down Arrow         向下翻滚一行</div><div class="line">G                  移动到最后一行</div><div class="line">g                  移动到开头一行</div><div class="line">/charaters         向前查找指定的字符串</div><div class="line">n                  向前查找下一个出现的字符串，这个字符串是之前所指定查找的</div><div class="line">q                  退出 less 程序</div></pre></td></tr></table></figure>
<h2 id="2-Git"><a href="#2-Git" class="headerlink" title="2. Git"></a>2. Git</h2><h3 id="2-1-Linus-Torvalds"><a href="#2-1-Linus-Torvalds" class="headerlink" title="2.1 Linus Torvalds"></a>2.1 Linus Torvalds</h3><p><img src="img/1377031471_938.jpg" alt="Linus"></p>
<p><img src="img/t010e327a72f8865f0d.png" alt="Linus"></p>
<p><img src="img/PicMonkey-Collage7.jpg7.jpg" alt="Linus"></p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Linux" target="_blank" rel="external">维基百科 - Linux</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E5%85%B9" target="_blank" rel="external">维基百科 - 林纳斯·托瓦兹</a></li>
<li><a href="http://baike.baidu.com/link?url=Op2mSoEhkUBdsOm-dPMHptZLBB5tiM2Evcv4lWorDH8JDHlqLtJkUsqDpDYRC7Go31N8tbjTJsYMwtz3NyKz3Ootoo4Gv35Z-SueSjmnpnSrc8X9gfjF-0N4QQv2LrNNTgR1nso1m7lXdOrmrxcNyr1iK5ZxvQ_-aikeGGZm2lu" target="_blank" rel="external">百度百科 - 林纳斯·托瓦兹</a></li>
<li><a href="https://www.zhihu.com/question/21994269" target="_blank" rel="external">林纳斯·托瓦兹 (Linus Torvalds) 为什么被称作大神？</a></li>
<li><a href="http://blog.csdn.net/turingbook/article/details/1775488" target="_blank" rel="external">Linux之父炮轰C++：糟糕程序员的垃圾语言</a></li>
<li><a href="https://www.youtube.com/watch?v=iYWzMvlj2RQ" target="_blank" rel="external">YouTube - Linus Torvalds: Nvidia, * You!</a></li>
<li>颠覆世界的“自由主义教皇”林纳斯</li>
<li>1969年12月28日出生于芬兰赫尔辛基市，目前拥有美国国籍</li>
<li>Linux内核的最早作者，随后发起了这个开源项目，担任Linux内核的首要架构师与项目协调者</li>
<li>当今世界最著名的电脑程序员、黑客之一</li>
<li>还发起了Git这个开源项目，并为主要的开发者</li>
<li>书籍推荐<ul>
<li><a href="https://www.amazon.cn/dp/B00MB51SAI/ref=sr_1_1?ie=UTF8&amp;qid=1475776251&amp;sr=8-1&amp;keywords=%E5%8F%AA%E6%98%AF%E4%B8%BA%E4%BA%86%E5%A5%BD%E7%8E%A9" target="_blank" rel="external">只是为了好玩:Linux之父林纳斯自传</a></li>
<li>吴军博士<ul>
<li>浪潮之巅</li>
<li>数学之美</li>
<li>文明之光</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-诞生背景"><a href="#2-2-诞生背景" class="headerlink" title="2.2 诞生背景"></a>2.2 诞生背景</h3><p>Git 是一个版本控制管理工具：</p>
<ul>
<li>保存历史记录</li>
<li>多人协同交互</li>
</ul>
<p>Git 翻译过来就是 饭桶 的意思，老外就是喜欢这样的命名。</p>
<p>例如：gulp、grunt、bower（类似于npm，前端包管理工具）、formidable、amazing、awesome、great</p>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137402760310626208b4f695940a49e5348b689d095fc000" target="_blank" rel="external">Git的诞生</a></li>
<li><a href="http://www.nowamagic.net/academy/detail/48160205" target="_blank" rel="external">Git诞生背后的一些故事</a></li>
<li><a href="https://git-scm.com/book/zh/ch1-2.html" target="_blank" rel="external">Git 简史</a></li>
<li><a href="http://www.oschina.net/news/73361/git-11-bitkeeper?p=1" target="_blank" rel="external">Git 诞生 11 年后，BitKeeper 宣布开源</a></li>
<li>Linus 原来带领数百万人开发 Linux 操作系统</li>
<li>使用 BitKeeper 作为团队的版本协同工具<ul>
<li>商业收费</li>
<li>免费给 Linux 开发团队使用</li>
</ul>
</li>
<li>直到有一天，其中有个开发人员试图去破解 BitKeeper 这个收费软件</li>
</ul>
<ul>
<li>被 BitKeeper 发现了，就要收回 Linux 团队的免费使用权限</li>
<li>Linus 大神一怒之下，在两三个星期之内就开发出了 Git 的初版</li>
</ul>
<h3 id="2-3-分布式版本控制"><a href="#2-3-分布式版本控制" class="headerlink" title="2.3 分布式版本控制"></a>2.3 分布式版本控制</h3><p><img src="img/分布式版本控制.png" alt="分布式版本控制"></p>
<h3 id="2-4-安装和配置-Git-环境"><a href="#2-4-安装和配置-Git-环境" class="headerlink" title="2.4 安装和配置 Git 环境"></a>2.4 安装和配置 Git 环境</h3><p>下载地址：<a href="https://git-for-windows.github.io/" target="_blank" rel="external">https://git-for-windows.github.io/</a></p>
<p>历史版本地址：<a href="https://github.com/git-for-windows/git/releases" target="_blank" rel="external">https://github.com/git-for-windows/git/releases</a></p>
<p>确认是否有 git 环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git --version</div></pre></td></tr></table></figure>
<p>如果看到能输出一个版本号 <code>git version 2.10.1.windows.1</code>（版本不一定一致），说明没有问题。</p>
<h3 id="2-5-初始设置"><a href="#2-5-初始设置" class="headerlink" title="2.5 初始设置"></a>2.5 初始设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name <span class="string">"yourname"</span></div><div class="line">$ git config --global user.email <span class="string">"your_email@example.com"</span></div></pre></td></tr></table></figure>
<p>设置一下提交记录中的日志信息，待会儿让可以通过查看提交日志看到，<br>执行上面两条命令在任何目录都可以，而且只需要在第一次安装了 git 环境之后配置一下即可。</p>
<p>如果想要修改，可以使用上面命令重新执行即可修改，<br>也可以使用另外一种方式，执行上面命令之后会在用户目录下生成一个叫做 <code>.gitconfig</code> 的文件，<br>所以也可以通过修改该文件来修改git的配置。</p>
<h3 id="2-6-基本操作"><a href="#2-6-基本操作" class="headerlink" title="2.6 基本操作"></a>2.6 基本操作</h3><ul>
<li><p><code>git init</code></p>
<ul>
<li>通过该命令创建一个本地仓库</li>
<li>执行过后，会在目录下生成一个 <code>.git</code> 隐藏目录，最好不要手动修改</li>
</ul>
</li>
<li><p><code>git status</code></p>
<ul>
<li>查看当前工作树状态</li>
<li>例如有新增的文件、修改的、删除的、等操作没有被添加到暂存区或者没有被提交</li>
<li>都可以通过 git status 命令看到</li>
</ul>
</li>
<li><p><code>git add 文件名</code></p>
<ul>
<li>将制定的文件添加到暂存区（待提交列表）</li>
</ul>
</li>
<li><p><code>git commit -m &quot;提交日志&quot;</code></p>
<ul>
<li>将暂存区（待提交列表）中的文件提交到本地仓库，形成一个历史快照</li>
</ul>
</li>
<li><p><code>git log</code></p>
<ul>
<li>查看提交日志</li>
</ul>
</li>
<li><p><code>gitk</code></p>
<ul>
<li>以图形化的界面查看本地仓库提交日志状态</li>
</ul>
</li>
</ul>
<h3 id="2-7-更改提交的操作"><a href="#2-7-更改提交的操作" class="headerlink" title="2.7 更改提交的操作"></a>2.7 更改提交的操作</h3><p>指定文件回滚：</p>
<ul>
<li><p><code>git checkout [file]</code></p>
<ul>
<li>恢复暂存区的指定文件到工作区</li>
</ul>
</li>
<li><p><code>git checkout [commit] [file]</code></p>
<ul>
<li>恢复某个commit的指定文件到暂存区和工作区</li>
</ul>
</li>
<li><p><code>git checkout .</code></p>
<ul>
<li>恢复暂存区的所有文件到工作区</li>
</ul>
</li>
</ul>
<p>指定版本回滚：</p>
<ul>
<li><p><code>git reset --hard</code></p>
<ul>
<li>恢复暂存区和工作区到上一次最新的提交</li>
</ul>
</li>
<li><p><code>git reset --hard 提交哈希值</code></p>
<ul>
<li>根据提交哈希值（版本号）回溯到历史版本</li>
</ul>
</li>
<li><p><code>git reflog</code></p>
<ul>
<li>查看当前仓库操作日志</li>
</ul>
</li>
<li><p><code>git commit --amend</code></p>
<ul>
<li>修改最近一次提交的提交日志</li>
</ul>
</li>
</ul>
<h3 id="2-8-推送至远程仓库"><a href="#2-8-推送至远程仓库" class="headerlink" title="2.8 推送至远程仓库"></a>2.8 推送至远程仓库</h3><p>如果已经有了一个本地仓库，就可以通过下面的形式和线上的空仓库产生关联：</p>
<ul>
<li>remote 添加远程仓库地址</li>
<li>add commit branch 等操作</li>
<li>pull</li>
<li><p>push</p>
</li>
<li><p><code>git remote add origin 远程仓库地址</code></p>
<ul>
<li>git 会自动将远程仓库地址起个别名 origin</li>
</ul>
</li>
<li><code>git push -u origin master</code><ul>
<li>推送到名称为 origin 远程仓库地址下的 master 分支下</li>
</ul>
</li>
</ul>
<h3 id="2-9-从远程仓库获取"><a href="#2-9-从远程仓库获取" class="headerlink" title="2.9 从远程仓库获取"></a>2.9 从远程仓库获取</h3><p>如果已经创建了一个远程仓库，就可以遵循下面的模式进行开发：</p>
<ul>
<li>clone</li>
<li>add commit branch 等操作</li>
<li>Pull</li>
<li><p>push</p>
</li>
<li><p><code>git clone 仓库地址</code></p>
<ul>
<li>git 会自动将 origin 设置为该远程仓库地址的标识符</li>
</ul>
</li>
<li><code>git pull</code></li>
</ul>
<p>所以在进行 push 之前，最好前 pull 一下，拉取最新源代码。</p>
<h3 id="2-10-学习资料推荐"><a href="#2-10-学习资料推荐" class="headerlink" title="2.10 学习资料推荐"></a>2.10 学习资料推荐</h3><ul>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">git - 简明指南</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰 - git教程</a></li>
<li><a href="https://git.oschina.net/progit/" target="_blank" rel="external">Pro Git</a></li>
<li><a href="http://backlogtool.com/git-guide/cn/" target="_blank" rel="external">猴子都能懂的git入门</a></li>
<li><a href="http://gitref.org/zh/remotes/" target="_blank" rel="external">git参考手册</a></li>
<li><a href="http://item.jd.com/11733256.html" target="_blank" rel="external">github入门与实践</a></li>
<li><a href="http://item.jd.com/11615420.html" target="_blank" rel="external">Git版本控制管理</a></li>
</ul>
<hr>
<h2 id="3-Github"><a href="#3-Github" class="headerlink" title="3. Github"></a>3. Github</h2><p>我们不是程序员，我们是只是 github 的搬运工。</p>
<p>现代开发，一个不会 <code>Google</code>，没上过 <code>GitHub</code>，不知道 <code>StackoverFlow</code> 的程序员是一件很可怕的事情！</p>
<p><img src="img/github-octocat.png" alt="github-octocat.png"></p>
<p><a href="https://github.com/" target="_blank" rel="external">Github</a> 是为开发者提供 Git 仓库的托管服务。<br>是一个可以让开发者与朋友、同事、同学及陌生人共享代码的完美平台。<br>简而言之，Github 就是程序员的新浪微博，社交化编程。</p>
<ul>
<li><a href="https://guides.github.com/" target="_blank" rel="external">GitHub Guides</a></li>
<li><a href="https://www.youtube.com/githubguides" target="_blank" rel="external">GitHub Training &amp; Guides</a></li>
<li><a href="http://item.jd.com/11733256.html" target="_blank" rel="external">GitHub入门与实践</a></li>
</ul>
<h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><ul>
<li>Github 与 Git 的区别<ul>
<li>Git 是一个分布式版本控制系统<ul>
<li>历史记录的问题</li>
<li>多人协作的问题</li>
</ul>
</li>
<li>Github 是为开发者提供 Git 仓库的托管服务</li>
</ul>
</li>
<li>不仅仅是 Git 仓库的托管服务</li>
<li>社交元素：项目点赞、关注项目Watch、Pull Request 等功能<ul>
<li>Pull Request：假设你修改了一个开源仓库源代码</li>
<li>你可以通过 Pull Request 请求合并，请求合并到源代码仓库中</li>
<li>当你发送了请求合并，别人会收到你的合并请求，然后会检查你的合并请求，如果没有问题，就可以直接合并到源代码库中</li>
</ul>
</li>
<li>Github Flavored Markdown<ul>
<li>写说明文档、发布评论等都使用的是 Markdown</li>
</ul>
</li>
<li>基本上各大开源产品都在 Github 上<ul>
<li>jQuery、bootstrap、AngularJS、Vue、React、Node</li>
</ul>
</li>
</ul>
<h3 id="3-2-基本使用"><a href="#3-2-基本使用" class="headerlink" title="3.2 基本使用"></a>3.2 基本使用</h3><ul>
<li>创建账户</li>
<li>设置头像</li>
<li>创建仓库</li>
<li>连接仓库</li>
<li>公开代码<ul>
<li>克隆仓库 clone</li>
<li>编写代码</li>
<li>提交 commit</li>
<li>进行 push</li>
</ul>
</li>
</ul>
<h3 id="3-3-使用-Github-Pages-搭建静态站点"><a href="#3-3-使用-Github-Pages-搭建静态站点" class="headerlink" title="3.3 使用 Github Pages 搭建静态站点"></a>3.3 使用 Github Pages 搭建静态站点</h3><p>[GitHub Pages -  官方教程]</p>
<p>我们可以把静态网站部署到 Github 上，然后通过特定的域名就可以访问了。</p>
<ol>
<li>在 github 上创建一个空仓库，仓库名称以 <code>你自己github用户名.github.io</code></li>
<li>然后提交文件到该仓库中，注意：仓库根路径必须有一个 index.html 文件</li>
<li>接下来就可以通过 <code>你自己的github用户名.github.io</code> 来访问你托管的那个静态网站仓库了，默认去找 index.html 页面</li>
</ol>
<p>还可以通过创建不同名字的仓库用来托管别的静态网站项目，如果想要通过你的github域名来访问，<br>就必须把你托管的文件放到一个叫做 <code>gh-pages</code> 的分支中。<br>然后就可以通过 <code>你的github用户名.github.io/拥有gh-pages分支的仓库名称</code> 来访问你的这个网站了</p>
<hr>
<h3 id="3-4-Github-总结"><a href="#3-4-Github-总结" class="headerlink" title="3.4 Github 总结"></a>3.4 Github 总结</h3><ul>
<li>有的公司用 Github</li>
<li>Gitlab 搭建在公司内部本地<ul>
<li>一个开源的类似于 Github 功能的网站，开源部署在本地免费使用</li>
<li>有一些公司也是自己搭建的 Gitlab 本地仓库服务供团队开发使用</li>
</ul>
</li>
<li>coding</li>
<li>bitbucket<ul>
<li>开源免费托管私有仓库</li>
</ul>
</li>
</ul>
<h2 id="4-使用-Hexo-搭建自己的个人静态博客"><a href="#4-使用-Hexo-搭建自己的个人静态博客" class="headerlink" title="4. 使用 Hexo 搭建自己的个人静态博客"></a>4. 使用 Hexo 搭建自己的个人静态博客</h2><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a></p>
<ul>
<li>必须安装 Node 环境<ul>
<li>通过在终端任意目录输入 <code>node -v</code> 查看是否有输入node的版本</li>
</ul>
</li>
<li>在终端的任意目录输入 <code>npm install -g hexo-cli</code> 然后回车执行等待安装成功<ul>
<li>通过输入 <code>hexo --version</code> 如果看到输入一大堆的版本号就说明安装成功了</li>
<li>Hexo 是一个命令行应用程序</li>
</ul>
</li>
<li>接下来通过输入 <code>hexp init 博客项目存储目录</code><ul>
<li>Hexo 会在你执行该命令的目录下生成一个博客项目</li>
<li>初始化博客项目的过程需要联网</li>
</ul>
</li>
<li>接下来通过终端进入刚才创建的博客项目目录，然后在该目录下输入 <code>npm install</code> 回车等待执行结束</li>
<li><p>接下来输入 <code>hexo server</code> 回车执行，它会在你的本地启动一个服务器，然后就可以访问你的博客项目</p>
</li>
<li><p>进入博客项目，输入 <code>hexo new 文章名称</code> 创建博客</p>
<ul>
<li>该命令会自动在 source/_posts/ 目录下生成一个 文章名称.md 文件</li>
</ul>
</li>
<li><p>生成静态文件：<code>hexo generate</code></p>
<ul>
<li>该命令会自动在项目的根目录下的 public 目录下降静态文件放进去吧</li>
</ul>
</li>
<li><p>快速部署</p>
<ul>
<li>修改配置文件</li>
<li>在项目根路径下执行 <code>npm install hexo-deployer-git --save</code> 该命令</li>
<li>接下来就可以直接输入 <code>hexo deploy --generate</code> 自动发布到 github 上</li>
</ul>
</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>能掌握 browser-sync 工具的基本使用</li>
<li>能掌握终端的基本命令使用</li>
<li>能掌握 Git 的基本使用（init、status、add、commit、log）</li>
<li>能掌握 GitHub 的基本操作流程（仓库、clone、push）</li>
<li>能掌握使用 Hexo 结合 Github Pages 功能搭建个人静态博客</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/nidun.jpg"
               alt="牛顿丶" />
          <p class="site-author-name" itemprop="name">牛顿丶</p>
          <p class="site-description motion-element" itemprop="description">Write less do more!</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangzhenyin" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="yangzhenying.github.io" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">牛顿丶</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
